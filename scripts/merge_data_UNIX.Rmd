---
title: "merge_data"
author: "Aske Svane Qvist"
date: "20 April 2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Merging The Data

This script merges the gathered Boris and Pupil files, 'boris_cleaned.csv' and 'pupil_cleaned.csv' according to similar timestamps. The fixation duration from the pupil data (recorded by the eye tracker) is to be employed in the analysis together with the manually annotated features of the bricks the children are looking at and interacting with.


## Import packages
```{r}
# Import packages using pacman
library(pacman)
p_load(tidyverse, rjson)

```

## Import data
```{r}
# Import the cleaned boris and pupil data from the folder 'gathered_data'
boris <- read_csv("../data/gathered_files/boris_cleaned.csv")
pupil <- read_csv("../data/gathered_files/pupil_cleaned.csv")

```

## Timestamp function
This function will convert timestamps from pupil timestamps to UNIX timestamps and will be used in the loop further down to gather the pupil and boris data. The function takes 3 parameters: 'synced_timestamp' is any given pupil timestamp of a fixation in the pupil data to be converted to UNIX, 'start_time_synced_s' is a constant extracted from the corresponding json-file generated by the eye-tarcker and is the pupil start time timestamp, 'start_time_system_s' is as well a constant extracted from the json-file and is the UNIX starttime timestamp. The output returned by the function is the input timestamp converted to UNIX.


```{r}
# The function
pupil_to_unix_timestamp <- function(synced_timestamp, start_time_synced_s, start_time_system_s){
  # Calculate the unix timestamp
  unix_timestamp <- as.numeric(synced_timestamp) - start_time_synced_s + start_time_system_s
  # Return value
  return(unix_timestamp)
  
}

```


## Merge all data
Loop over every ID and block one by one
```{r}

# Save the filepath to the jsonfiles with the timestamps
json_path <- "../data/Pupil_Labs_raw_data/info.player/"

# Make lists of unique ID's and blocks to enable looping over each ID and block one by one.
ID_list <- unique(boris$participantID)


dataAll <- tibble()
# Loop over every ID
for (ID_idx in 1:length(ID_list)){

  # Get iD one by one
  ID <- ID_list[ID_idx]

  # Loop over every block (under each ID)
  for (b in 1:3){
    
    # get data from the current ID and block
    pupil_sub <- pupil %>% filter(participantID == ID & block == b)
    boris_sub <- boris %>% filter(participantID == ID & block == b)
    
    # Paste together a filename based on the current ID and block number.
    json_file <- paste(json_path, "info.player_P", as.character(ID),"_B", as.character(b),".json", sep = "")
    # import json-file and convert into df to enable easy data handling
    timestamps <- as.data.frame(fromJSON(file = json_file))
    ## Extract constants from the corresponding json file (to feed into the predefined function to convert timestamps)
    start_time_synced_s <- as.numeric(timestamps[1,"start_time_synced_s"]) # Pupil timestamp
    start_time_system_s <- as.numeric(timestamps[1,"start_time_system_s"])# Unix timestamp
    
    # feed the function with the pupil timestamps in the column 'start_timestamps' and the constants just extracted. 
    # Subtract the unix start_time_system_s stamp.
    pupil_sub <- pupil_sub %>% 
      mutate(time_unix = (pupil_to_unix_timestamp(start_timestamp, start_time_synced_s, start_time_system_s)) - start_time_system_s)

    
    # Create empty tibble for all the new merged rows
    data_merged <- tibble()
    
    # Loop over every fixation in the boris data and find the corresponding row in the pupil data 
    # merge them and save to data_merged
    for (i in 1:nrow(boris_sub)){
      # Get row from boris
      row <- boris_sub[i,]
  
      # get the timestamp for the fixation
      timestamp <- as.numeric(row[1,"time"])
  
  
      # Calculate time difference for each time stamp in boris and extract the row where the differece is lowest
      pupil_row <- pupil_sub %>% mutate(
        time_dif = abs(time_unix - timestamp)
    
      )
  
      # Extract the row corresponding to the annotated fixation in boris
      pupil_row <- pupil_row[pupil_row$time_dif == min(pupil_row$time_dif),-c(8,9)]

      # column bind the two dfs
      combined <- cbind(row, pupil_row)
  
      #Combine with premade empty dataframe
      if (nrow(data_merged) == 0) {
        data_merged <- combined}
      else {
        data_merged <- rbind(data_merged, combined)}
    }
    
    # Append the df to dataAll outside the loop
    if (nrow(dataAll) == 0){
      dataAll <- data_merged}
    else {
      dataAll <- rbind(dataAll, data_merged)}
    
  }
}



```


## Overview, write to csv and clean environment
```{r}
# Quick overview to spot potential mistakes
summary <- dataAll %>% 
  group_by(participantID, block) %>% 
  summarise(n_fixations = n(),
            boris_dur = max(time),
            pupil_dur = max(time_unix))

# save as csv file
write_csv(dataAll,"../data/gathered_files/dataAll.csv")


# remove temporary loop objects from the environment
rm(b, i, ID, ID_idx, ID_list, json_file, json_path, start_time_synced_s, start_time_system_s, timestamp, row, timestamps, pupil_row, pupil_sub, boris_sub, combined, data_merged)

```




# This should be deleted
## Remove duplicated merged rows from the data
Since the Boris and the Pupil data have been merged according similar timestamps, some rows from the Pupil data will inevitably be merged more than once to different timestamps in the Boris data. This is due to the fact that for each fixation in the Boris data, the fixation in the Pupil data with the shortest distance will be appended. If the fixation in the pupil data is the closest to more than one fixation in the Boris data, it will be appended more than once.

If the duration of a fixation is longer than the time difference between a given fixation and the following, the row from the pupil data must have been falsly appended. I remove these.


```{r}
# Create two new columns, one with time duration in seconds corresponding to the other timestamps and one with the subsequent fixation timestamp. I use these two new columns to ensure that only fixations with realistic fixation durations are kept.
data <- data %>% 
  mutate(
    duration_sek = duration_ms / 1000,
    time_lead = lead(time))

# Remove falsly merged rows.
data <- data[data$time + data$duration_sek < data$time_lead,]

```














